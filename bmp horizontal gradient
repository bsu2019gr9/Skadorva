#include <iostream>
#include <fstream>

using namespace std;

struct color { unsigned char r; unsigned char g; unsigned char b; } c;
int main() {
    ifstream fff("c:\\IT\\3.bmp", ios::binary); //  ios::binary влияет ТОЛЬКО на endl.
    ofstream ggg("c:\\IT\\rez2.bmp", ios::binary);//сюда пишем (поток типа ofstream= output file stream)
    if (!fff) { cout << "No file d:\\1.bmp. Can't open\n"; exit(1); }
    if (!ggg) { cout << "   file d:\\rez.bmp. Can't create\n"; exit(1); }

    char buf[30];// куда читать байты
    unsigned char r, g, b;//компоненты цвета
    color c;
    unsigned int w, h;//надеемся. что тут 4 байта

    fff.read((char*)&buf, 18);   //чтение 18 байт заголовка bmp
    ggg.write((char*)&buf, 18);    //запись 18 байт заголовка bmp
    fff.read((char*)&w, 4); cout << "w=" << w;   //чтение width из заголовка bmp
    fff.read((char*)&w, 4); cout << ", h=" << w; //чтение height из заголовка bmp
    w = 32; ggg.write((char*)&w, 4);    //запись width в заголовок bmp ( w кратно 4, обязательно для нас, чтобы не делать выравнивание)
    h = 128; ggg.write((char*)&h, 4);    //запись height в заголовок bmp
    fff.read((char*)&buf, 28);   //чтение 28 байт заголовка bmp
    ggg.write((char*)&buf, 28);    //запись 28 байт заголовка bmp

    c.r=c.g=c.b=0;
    for(int i=1;i<=h;++i){
     /*    ++r;g=0;b=0;*/
    for(int j=1;j<=w;++j){
        ggg.write((char *)&c, 3);     //запись сразу всего цвета
        ++c.r; ++c.g;
     /*    ggg.write((char *)&b, 1);   //запись одной компоненты цвета
        ggg.write((char *)&g, 1);    //запись одной компоненты цвета
        ggg.write((char *)&r, 1);    //запись одной компоненты цвета
        ++g;
        */
    }
    c.b = c.r = c.g = 0;
    }

    fff.close();//закрыли файл
    ggg.close();//закрыли файл
    return 1;
}
